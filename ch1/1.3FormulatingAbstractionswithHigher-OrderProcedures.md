# 1.3 Formulating Abstractions with Higher-Order Procedures

## 原书目录

- 1.3.1 Procedures as Arguments]()
- 1.3.2 Constructing Procedures Using Lambda]()
- 1.3.3 Procedures as General Methods]()
- 1.3.4 Procedures as Returned Values]()

## 1.3.1Procedures as Arguments

我们学过了如何写表达式，如何组合表达式，并加以抽象，隐藏实现细节，重用procedure。

比如，计算两个数的和，我们可以：

- 直接用 1 + 2

- 定义一个procedure

```
define sum(a, b):
	return a + b
```

- 执行procedure

```
sum(1, 2)
```

上面求的是两个数的和，那如果我们多求几个数，比如1到10：

- 可以加个循环调用sum(a, b)

  ```
  def sum_loop(a, b):
      ''' use loop to calc sum of numbers between a and b'''
      total = 0
      for i in range(a, b+1):
          total += i
      return total
  ```

  需要思考一下，如果上面换成是求a 到 b所有数的平方和，上面的函数就得改写了

- 但是作者用的递归实现，确实很直观。

  ```
  def sum_ints(a, b):
      '''# calcualte sum of numbers in between a and b'''
      if a > b:
          return 0
      else:
          return a + sum_ints(a+1, b)
  ```

  同样，如果要求平方和，就得另写一个函数：

  ```
  def sum_of_squares(a, b):
      '''# calcualte sum of the square of numbers in between a and b'''
      if a > b:
          return 0
      else:
          return square(a) + sum_of_squares(a+1, b)
  ```

  观察一下这两个函数，找一下共性：

  - 退出条件相同 (if a > b)
  - body相似：变数FX + 函数自身调用

  进一步思考，如果我们把共性的地方提出来，将变数X作为参数，是否就可以写成一个新函数：

  ```
  def newfunc(fx, a, b):
  	if a > b:
          return 0
      else:
          return fx(a) + sum_of_squares(a+1, b)
  ```

  事实上确实是可以的，python lisp都支持这个功能，即函数作为实参。

  ```
  def calc_2(fx, a, b):
      '''abstract from itself and sum_of_squares functions'''
      if a > b:
          return 0
      else:
          return fx(a) + calc_2(f, a+1, b)
  ```

  至此，我们看到，定义一个procedure，可以给它传入不同类型的参数：

  - numbers，
  - other expressions
  - **函数**

  这有什么好处？以求和为例，同一个函数只要变换不同的参数fx，就可以实现不同类型的求和

  ```
  calc_2(square, 1, 10)
  ```

  ```
  calc_1(sum_ints, 1, 10)
  ```

  

本节求多个数的和作者依然用的递归来讲述，是因为讲述起来比较直观呢还是啥？【】

还有一个问题，其实数学上，求1到n的和是有具体公式的，比如


$$
s_1.._n = n(n+1)/2
$$
求1到n的平方和：
$$
s_1.._n^2 = n(n+1)(2n+1)/6
$$
为什么作者不直接套用公式呢？应该是为了讲述原理吧。当n很大的时候，这个公式会很复杂，可能没有固定公式吧（不确定），老老实实的递推吧

[数学的发现](https://book.douban.com/subject/1850407/)中，从推到求1到n的平方和，引出了递归，明白了为什么：
$$
(n+1)^4 -1 = 4S_3 + 6 S_2 + 4S_1 + S_0
$$
其中 

$$S_3$$ ：1到3的平方和

$$S_2$$： 1到2的平方和
....

可见，只要知道了 $$S_2, S_1, S_0$$ 便能算出$$S_3$$的值了，而$$S_2$$计算需要先算出$$S_1$$，同理$$S_1$$需要知道$$S_0$$。而$$S_0$$容易算出，所以一路再倒推回去便算出$$S_3$$了。



## 1.3.2 Constructing Procedures Using Lambda]()

## 1.3.3 Procedures as General Methods]()

## 1.3.4 Procedures as Returned Values]()