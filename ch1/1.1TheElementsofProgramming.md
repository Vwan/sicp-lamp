# 1.1 编程语言的要素 (The Elements of Programming)

## 编程语言？

编程语言能**让机器来做事**，好的编程语言还考虑到编程者自身，如何让编程者有效的将简单的想法组织成复杂的想法，从而**让机器来做事**。

【I】Paul Graham在 Design and Research中提到，Design非常重要的一点是，以特定用户群为核心，并且，设计者本身也要把自己纳入该特定用户群中，这样才能切实的体会用户需求，设计贴近用户的产品功能。放到编程语言的设计上也是如此。好的编程语言，要考虑到使用该语言的程序员们自身

> You are most likely to get good design if the intended users include the designer himself. When you design something for a group that doesn't include you, it tends to be for people you consider less sophisticated than you, not more sophisticated. And looking down on the user, however benevolently, always seems to corrupt the designer. ——Paul Graham

这也是LISP语言是开发之母的原因，设计者自身便是使用者。所以全书也是以LISP为主来介绍。

作者认为好的编程语言有三个要素：

> - **primitive expressions**, which represent the simplest entities the language is concerned with,
> - **means of combination**, by which compound elements are built from simpler ones, and
> - **means of abstraction**, by which compound elements can be named and manipulated as units.

试着理解一下，以前我们学编程的时候，一般教科书或者培训流程都是这样的：

1. "Hello world" -> 2. 变量类型 -> 3. 基础/逻辑运算（+-*/…或与非…) -> 4. 控制流程(if, loop) -> 5.  函数、方法() -> 6. 类()…等

1-3 应该是最基础的表达方式了，4 则是1-3的各种组合方式，5以上便是抽象了。编程很重要的一点是学会抽象，这也是我很期待从本书中学到的。

## 过程(Procedure)和数据(Data)

有一道面试题问：面向过程和面向对象有什么区别？本书没有提到对象，但提到了数据。（是否对象其实也是数据的一种？）

什么是过程？英文Procedure，英文解释是：an established or official way of doing something. 那因为编程是让机器来做事，所以便是我们通过指定一系列的规则让机器来操作，操作什么呢？数据。

数据又是什么呢？巧妇难为无米之炊，数据就是米，是要做熟饭所需的任何物料（stuff）。

## 表达式（Expressions）

我想到的最简单的表达式 2 + 3，但作者举例的最简单的表达式就是一个数字 2。数字何以成表达式了？不解。【I】数字何以成表达式，目前的理解是，数字 = 数字 + 0

而 2 + 3 则是一个复杂的表达式。

这里怎么理解呢？作者认为表达式包括：

- 表示数字的，如 Number 5
- 表示Procedure的，如+，-
  - 【I】"+"只是一个符号而已，但它传达的是一个动作（操作），所以可以表示Procedure。Procedure是按照既定程式做事，如将5和4加起来

这两者结合在一起，便成了复杂的表达式 如 5 + 4, 表示Procedure "+" 应用到数字5和4上，称之为**组合(Combinations)**, "+" 称为**操作符**，5和4称为**操作数****的值(Arguments)**。

Python：

```
5 + 4
5 + 4 + 3
5 + 4 * 3
```

Lisp：```(+ 5 4)```

```
(+ 5 4)
(+ 5 4 3)
(+ 5 (* 4 3))
```

【I】比较上面第三个长表达式，计算机在处理的时候，哪种语言的表达效率更快呢？

​            [计算机加减乘除的具体实现及数学原理？ - 知乎](https://www.zhihu.com/question/21387550)

计算机在处理加减乘除时，会先转换成后缀表达式，然后再通过栈来处理后缀表达式，基本原则是：

- 从左到右遍历后缀表达式的数字和符号
  - if 数字，则入栈
  - if 符号，则将栈顶的两个数字出栈
    - 进行运算
    - 运算结果入栈
  - 直至到最终结果

后缀表达式的转换原则：

- 从左到右遍历表达式的数字和符号
  - if 数字，则直接输出为后缀表达式的一部分
  - if 符号，则判断其与栈顶符号的优先级
    - if ） or 优先级低于栈顶符号，则
      - 栈顶元素依次出栈并输出
      - 当前符号进栈
    - else 当前符号进栈

以转换后缀表达式为例，原表达式（9+（3-1）*3+10/2）用Python和Lisp比较一下过程：后缀表达式 E

Python: 9+（3-1）*3+10/2

栈顶->底：					E = 9	

栈顶->底：	  ( +				E = 9 3	

栈顶->底：	- ( +				E = 9 3	

栈顶->底：	+				E = 9 3 1-

栈顶->底：	***+**				E = 9 3 1-3

栈顶->底：	+				E = 9 3 1-3***+**	

栈顶->底：	/ +				E = 9 3 1-3*+10

栈顶->底：					E = 9 3 1-3*+10 2/+

Lisp: (+ 9 (* (- 3 1) 3) (/ 10 2))

栈顶->底：	+ (				E = 9	

栈顶->底：	 *(+(			E = 9	

栈顶->底：	-			E = 9 *+3 1	

栈顶->底：					E = 9 *+3 1-

好像不对啊，难道Lisp不需要转换成后缀表达式吗？

搜索了一下，发现表达式有多种表示方法：

- 中缀表达式，即我们人脑比较习惯的:（9+（3-1）*3+10/2）

- 计算机并不会处理中缀表达式，所以需要进行转换

  - [Polish notation - Wikipedia](https://en.wikipedia.org/wiki/Polish_notation) 前缀表达式：如 * + 3
    - 目测Lisp用的是前缀表达式，不过尚未找到直接说明
  - [Reverse Polish notation - Wikipedia](https://en.wikipedia.org/wiki/Reverse_Polish_notation)后缀表达式：见前面的例子

  

另外，Lisp 的表达式其实是一种树形结构：如(+ 9 (* (- 3 1) 3) (/ 10 2))

​					+

​		9			*				/

​				-		3		10		2

​			3		1

所有的事情都是由简单的事情组合而成，只是程度不同。



