# 1.1 编程语言的要素 (The Elements of Programming)

## 编程语言？

编程语言能**让机器来做事**，好的编程语言还考虑到编程者自身，如何让编程者有效的将简单的想法组织成复杂的想法，从而**让机器来做事**。

【I】Paul Graham在 Design and Research中提到，Design非常重要的一点是，以特定用户群为核心，并且，设计者本身也要把自己纳入该特定用户群中，这样才能切实的体会用户需求，设计贴近用户的产品功能。放到编程语言的设计上也是如此。好的编程语言，要考虑到使用该语言的程序员们自身

> You are most likely to get good design if the intended users include the designer himself. When you design something for a group that doesn't include you, it tends to be for people you consider less sophisticated than you, not more sophisticated. And looking down on the user, however benevolently, always seems to corrupt the designer. ——Paul Graham

这也是LISP语言是开发之母的原因，设计者自身便是使用者。所以全书也是以LISP为主来介绍。

作者认为好的编程语言有三个要素：

> - **primitive expressions**, which represent the simplest entities the language is concerned with,
> - **means of combination**, by which compound elements are built from simpler ones, and
> - **means of abstraction**, by which compound elements can be named and manipulated as units.

试着理解一下，以前我们学编程的时候，一般教科书或者培训流程都是这样的：

1. "Hello world" -> 2. 变量类型 -> 3. 基础/逻辑运算（+-*/…或与非…) -> 4. 控制流程(if, loop) -> 5.  函数、方法() -> 6. 类()…等

1-3 应该是最基础的表达方式了，4 则是1-3的各种组合方式，5以上便是抽象了。编程很重要的一点是学会抽象，这也是我很期待从本书中学到的。

## 过程(Procedure)和数据(Data)

有一道面试题问：面向过程和面向对象有什么区别？本书没有提到对象，但提到了数据。（是否对象其实也是数据的一种？）

什么是过程？英文Procedure，英文解释是：an established or official way of doing something. 那因为编程是让机器来做事，所以便是我们通过指定一系列的规则让机器来操作，操作什么呢？数据。

数据又是什么呢？巧妇难为无米之炊，数据就是米，是要做熟饭所需的任何物料（stuff）。

## 表达式（Expressions）

我想到的最简单的表达式 2 + 3，但作者举例的最简单的表达式就是一个数字 2。数字何以成表达式了？不解。【**TODO**】数字何以成表达式，目前的理解是，数字 = 数字 + 0

而 2 + 3 则是一个复杂的表达式。

这里怎么理解呢？作者认为表达式包括：

- 表示数字的，如 Number 5
- 表示Procedure的，如+，-
  - 【I】"+"只是一个符号而已，但它传达的是一个动作（操作），所以可以表示Procedure。Procedure是按照既定程式做事，如将5和4加起来

这两者结合在一起，便成了复杂的表达式 如 5 + 4, 表示Procedure "+" 应用到数字5和4上，称之为**组合(Combinations)**, "+" 称为**操作符**，5和4称为**操作数****的值(Arguments)**。

Python：

```
5 + 4
5 + 4 + 3
5 + 4 * 3
```

Lisp：```(+ 5 4)```

```
(+ 5 4)
(+ 5 4 3)
(+ 5 (* 4 3))
```

【**TODO**】比较上面第三个长表达式，计算机在处理的时候，哪种语言的表达效率更快呢？

​            [计算机加减乘除的具体实现及数学原理？ - 知乎](https://www.zhihu.com/question/21387550)

计算机在处理加减乘除时，会先转换成后缀表达式，然后再通过栈来处理后缀表达式，基本原则是：

- 从左到右遍历后缀表达式的数字和符号
  - if 数字，则入栈
  - if 符号，则将栈顶的两个数字出栈
    - 进行运算
    - 运算结果入栈
  - 直至到最终结果

后缀表达式的转换原则：

- 从左到右遍历表达式的数字和符号
  - if 数字，则直接输出为后缀表达式的一部分
  - if 符号，则判断其与栈顶符号的优先级
    - if ） or 优先级低于栈顶符号，则
      - 栈顶元素依次出栈并输出
      - 当前符号进栈
    - else 当前符号进栈

以转换后缀表达式为例，原表达式（9+（3-1）*3+10/2）用Python和Lisp比较一下过程：后缀表达式 E

Python: 9+（3-1）*3+10/2

栈顶->底：					E = 9	

栈顶->底：	  ( +				E = 9 3	

栈顶->底：	- ( +				E = 9 3	

栈顶->底：	+				E = 9 3 1-

栈顶->底：	***+**				E = 9 3 1-3

栈顶->底：	+				E = 9 3 1-3***+**	

栈顶->底：	/ +				E = 9 3 1-3*+10

栈顶->底：					E = 9 3 1-3*+10 2/+

Lisp: (+ 9 (* (- 3 1) 3) (/ 10 2))

栈顶->底：	+ (				E = 9	

栈顶->底：	 *(+(			E = 9	

栈顶->底：	-			E = 9 *+3 1	

栈顶->底：					E = 9 *+3 1-

好像不对啊，难道Lisp不需要转换成后缀表达式吗？

搜索了一下，发现表达式有多种表示方法：

- 中缀表达式，即我们人脑比较习惯的:（9+（3-1）*3+10/2）
- 计算机并不会处理中缀表达式，所以需要进行转换
  - [Polish notation - Wikipedia](https://en.wikipedia.org/wiki/Polish_notation) 前缀表达式：如 * + 3
    - 目测Lisp用的是前缀表达式，不过尚未找到直接说明
  - [Reverse Polish notation - Wikipedia](https://en.wikipedia.org/wiki/Reverse_Polish_notation)后缀表达式：见前面的例子

【**TODO**】了解前后缀表达式有什么意义？是否前后缀表达式对计算机而言有什么不同？

## 命名和环境

Lisp:

``` (define age 5)```

Python

``` age = 5```

【**TODO**】命名是个大学问，记得大妈曾在哪里贴过一个命名的链接，待找

这个值需要在某个地方存放着，以便以后调用，这个地方便是计算机的内存

## Evaluating Combinations

不知道如何翻译"Evaluate"，按字面意思是计算。本节中作者介绍了一个重要的思想：递归

对递归最浅显的认识是，调用自身，但是具体计算过程很迷糊。

【**TODO**】什么是组合？(define x 3)是组合吗？为什么？

Special Forms

### 递归

Recursive在字典中的解释，提到的也是我目前理解的，但是总感觉不是那么简单

```
characterized by recurrence or repetition.
• Mathematics & Linguistics relating to or involving the repeated application of a rule, definition, or procedure to successive results.
• Computing relating to or involving a program or routine of which a part requires the application of the whole, so that its explicit interpretation requires in general many successive executions.
```

到wiki上查找[Recursion - Wikipedia](https://en.wikipedia.org/wiki/Recursion)，发现之前理解的是非正式定义：

```
Recursion is the process a procedure goes through when one of the steps of the procedure involves invoking the procedure itself. A procedure that goes through recursion is said to be 'recursive'.
```

它的正式定义包含两个要素：

- 1个或多个终结递归的事件，称为base case(s)。即退出递归的条件，不然无限循环了。
- 一组规则：遵循该规则，所有base case(s)之外的其他事件层层递减趋向base case(s)，即趋于可以获得最终结果。

最典型的应用是[Fibonacci number - Wikipedia](https://en.wikipedia.org/wiki/Fibonacci_number)：

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/31a3ac9621fb67482cc66f1e2b370dede4fdb08d)![](https://wikimedia.org/api/rest_v1/media/math/render/svg/195ade62ee6aa7c8fdc0424ad64a61588e3e9010)

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/393d2f04e03a78c68e518b4f17a7c88a286782a8)

这里有两个base case: Fib(0) 和 Fib(1)。规则则是所有大于1的数，其Fibonacci数等于其前面两个数的和。

下面这张图是三个边长是Fibonacci数的正方形，Fib8 (21) = Fib7(13) + Fib6(5)。[![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/34%2A21-FibonacciBlocks.png/600px-34%2A21-FibonacciBlocks.png)](https://en.wikipedia.org/wiki/File:34*21-FibonacciBlocks.png)

用Python来实现：

```
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)

assert fibonacci(20)== 6765
```

用Lisp来实现：【**TODO**】

```
还不会，TODO
```



【**TODO**】看到一则关于Recursion的笑话，提到GEB的作者侯世达很懂Recursion，回头翻番GEB关于回归的部分

```
from Andrew Plotkin: "If you already know what recursion is, just remember the answer. Otherwise, find someone who is standing closer to Douglas Hofstadter than you are; then ask him or her what recursion is."
```



Lisp 的表达式其实是一种树形结构：如(+ 9 (* (- 3 1) 3) (/ 10 2))

​					+

​		9			*				/

​				-		3		10		2

​			3		1

书中用的是另一种树形结构，称为"Percolate upward form" Of tree structure. 

​					

​							20				

​	+		9		6						5

​		*			2		3			/	10	2	

​				-     3	1			



这种evaluating过程一般称为[Tree accumulation - Wikipedia](https://en.wikipedia.org/wiki/Tree_accumulation)，即从下往上计算，页节点是符号或数字，其母节点保存页节点的计算值，依次往上类推。比如美国大选统计各州的选票便可用此方式。与之相反的另一种evaluating过程称为Downward accumulation refers to accumulating on each node information of every ancestor.

这种树形结构有什么好处？阳志平老师提到：

```
人类的最佳知识结构是树形结构。
从树的上一层到下一层，是具备唯一通道，便于大脑将知识从记忆底层快速提取出来
树同时又兼具横向和纵向扩展的优雅结构
```

【**TODO**】那是不是可以理解，这种树形结构也是计算机容易理解的呢？树形结构和递归有什么关联？

【**TODO**】我们常用的表达方式（9+（3-1）*3+10/2），如果一定要写成树形的话，似乎也可以写。但第一感觉似乎还是偏于扁平结构了

变量的环境

递归有什么用？