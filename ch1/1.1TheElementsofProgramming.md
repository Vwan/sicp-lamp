# 1.1 编程语言的要素 (The Elements of Programming)

## 编程语言？

编程语言能**让机器来做事**，好的编程语言还考虑到编程者自身，如何让编程者有效的将简单的想法组织成复杂的想法，从而**让机器来做事**。

【I】Paul Graham在 Design and Research中提到，Design非常重要的一点是，以特定用户群为核心，并且，设计者本身也要把自己纳入该特定用户群中，这样才能切实的体会用户需求，设计贴近用户的产品功能。放到编程语言的设计上也是如此。好的编程语言，要考虑到使用该语言的程序员们自身

> You are most likely to get good design if the intended users include the designer himself. When you design something for a group that doesn't include you, it tends to be for people you consider less sophisticated than you, not more sophisticated. And looking down on the user, however benevolently, always seems to corrupt the designer. ——Paul Graham

这也是LISP语言是开发之母的原因，设计者自身便是使用者。所以全书也是以LISP为主来介绍。

作者认为好的编程语言有三个要素：

> - **primitive expressions**, which represent the simplest entities the language is concerned with,
> - **means of combination**, by which compound elements are built from simpler ones, and
> - **means of abstraction**, by which compound elements can be named and manipulated as units.

试着理解一下，以前我们学编程的时候，一般教科书或者培训流程都是这样的：

1. "Hello world" -> 2. 变量类型 -> 3. 基础/逻辑运算（+-*/…或与非…) -> 4. 控制流程(if, loop) -> 5.  函数、方法() -> 6. 类()…等

1-3 应该是最基础的表达方式了，4 则是1-3的各种组合方式，5以上便是抽象了。编程很重要的一点是学会抽象，这也是我很期待从本书中学到的。

## 过程(Procedure)和数据(Data)

有一道面试题问：面向过程和面向对象有什么区别？本书没有提到对象，但提到了数据。（是否对象其实也是数据的一种？）

什么是过程？英文Procedure，英文解释是：an established or official way of doing something. 那因为编程是让机器来做事，所以便是我们通过指定一系列的规则让机器来操作，操作什么呢？数据。

数据又是什么呢？巧妇难为无米之炊，数据就是米，是要做熟饭所需的任何物料（stuff）。

## 表达式（Expressions）

我想到的最简单的表达式 2 + 3，但作者举例的最简单的表达式就是一个数字 2。数字何以成表达式了？不解。【**TODO**】数字何以成表达式，目前的理解是，数字 = 数字 + 0

而 2 + 3 则是一个复杂的表达式。

这里怎么理解呢？作者认为表达式包括：

- 表示数字的，如 Number 5
- 表示Procedure的，如+，-
  - 【I】"+"只是一个符号而已，但它传达的是一个动作（操作），所以可以表示Procedure。Procedure是按照既定程式做事，如将5和4加起来

这两者结合在一起，便成了复杂的表达式 如 5 + 4, 表示Procedure "+" 应用到数字5和4上，称之为**组合(Combinations)**, "+" 称为**操作符**，5和4称为**操作数****的值(Arguments)**。

Python：

```
5 + 4
5 + 4 + 3
5 + 4 * 3
```

Lisp：```(+ 5 4)```

```
(+ 5 4)
(+ 5 4 3)
(+ 5 (* 4 3))
```

【**TODO**】比较上面第三个长表达式，计算机在处理的时候，哪种语言的表达效率更快呢？

​            [计算机加减乘除的具体实现及数学原理？ - 知乎](https://www.zhihu.com/question/21387550)

计算机在处理加减乘除时，会先转换成后缀表达式，然后再通过栈来处理后缀表达式，基本原则是：

- 从左到右遍历后缀表达式的数字和符号
  - if 数字，则入栈
  - if 符号，则将栈顶的两个数字出栈
    - 进行运算
    - 运算结果入栈
  - 直至到最终结果

后缀表达式的转换原则：

- 从左到右遍历表达式的数字和符号
  - if 数字，则直接输出为后缀表达式的一部分
  - if 符号，则判断其与栈顶符号的优先级
    - if ） or 优先级低于栈顶符号，则
      - 栈顶元素依次出栈并输出
      - 当前符号进栈
    - else 当前符号进栈

以转换后缀表达式为例，原表达式（9+（3-1）*3+10/2）用Python和Lisp比较一下过程：后缀表达式 E

Python: 9+（3-1）*3+10/2

栈顶->底：					E = 9	

栈顶->底：	  ( +				E = 9 3	

栈顶->底：	- ( +				E = 9 3	

栈顶->底：	+				E = 9 3 1-

栈顶->底：	***+**				E = 9 3 1-3

栈顶->底：	+				E = 9 3 1-3***+**	

栈顶->底：	/ +				E = 9 3 1-3*+10

栈顶->底：					E = 9 3 1-3*+10 2/+

Lisp: (+ 9 (* (- 3 1) 3) (/ 10 2))

栈顶->底：	+ (				E = 9	

栈顶->底：	 *(+(			E = 9	

栈顶->底：	-			E = 9 *+3 1	

栈顶->底：					E = 9 *+3 1-

好像不对啊，难道Lisp不需要转换成后缀表达式吗？

搜索了一下，发现表达式有多种表示方法：

- 中缀表达式，即我们人脑比较习惯的:（9+（3-1）*3+10/2）
- 计算机并不会处理中缀表达式，所以需要进行转换
  - [Polish notation - Wikipedia](https://en.wikipedia.org/wiki/Polish_notation) 前缀表达式：如 * + 3
    - 目测Lisp用的是前缀表达式，不过尚未找到直接说明
  - [Reverse Polish notation - Wikipedia](https://en.wikipedia.org/wiki/Reverse_Polish_notation)后缀表达式：见前面的例子

【**TODO**】了解前后缀表达式有什么意义？是否前后缀表达式对计算机而言有什么不同？

## 命名和环境

Lisp:

``` (define age 5)```

Python

``` age = 5```

【**TODO**】命名是个大学问，记得大妈曾在哪里贴过一个命名的链接，待找

这个值需要在某个地方存放着，以便以后调用，这个地方便是计算机的内存

## Evaluating Combinations

不知道如何翻译"Evaluate"，按字面意思是计算。本节中作者介绍了一个重要的思想：递归

对递归最浅显的认识是，调用自身，但是具体计算过程很迷糊。

### Special Forms

【**TODO**】什么是组合？(define x 3)是组合吗？为什么？

define 是个关键词，(define x 3) 是指将x与3关联起来，而非结合起来得到一个新的值，所以不是组合。

这种形式称为Special Forms.

### 递归

Recursive在字典中的解释，提到的也是我目前理解的，但是总感觉不是那么简单

```
characterized by recurrence or repetition.
• Mathematics & Linguistics relating to or involving the repeated application of a rule, definition, or procedure to successive results.
• Computing relating to or involving a program or routine of which a part requires the application of the whole, so that its explicit interpretation requires in general many successive executions.
```

到wiki上查找[Recursion - Wikipedia](https://en.wikipedia.org/wiki/Recursion)，发现之前理解的是非正式定义：

```
Recursion is the process a procedure goes through when one of the steps of the procedure involves invoking the procedure itself. A procedure that goes through recursion is said to be 'recursive'.
```

它的正式定义包含两个要素：

- 1个或多个终结递归的事件，称为base case(s)。即退出递归的条件，不然无限循环了。
- 一组规则：遵循该规则，所有base case(s)之外的其他事件层层递减趋向base case(s)，即趋于可以获得最终结果。

最典型的应用是[Fibonacci number - Wikipedia](https://en.wikipedia.org/wiki/Fibonacci_number)：

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/31a3ac9621fb67482cc66f1e2b370dede4fdb08d)![](https://wikimedia.org/api/rest_v1/media/math/render/svg/195ade62ee6aa7c8fdc0424ad64a61588e3e9010)

![](https://wikimedia.org/api/rest_v1/media/math/render/svg/393d2f04e03a78c68e518b4f17a7c88a286782a8)

这里有两个base case: Fib(0) 和 Fib(1)。规则则是所有大于1的数，其Fibonacci数等于其前面两个数的和。

下面这张图是三个边长是Fibonacci数的正方形，Fib8 (21) = Fib7(13) + Fib6(5)。[![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/34%2A21-FibonacciBlocks.png/600px-34%2A21-FibonacciBlocks.png)](https://en.wikipedia.org/wiki/File:34*21-FibonacciBlocks.png)

用Python来实现：

```
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)

assert fibonacci(20)== 6765
```

用Lisp来实现：【**TODO**】

```
还不会，TODO
```



【**TODO**】看到一则关于Recursion的笑话，提到GEB的作者侯世达很懂Recursion，回头翻番GEB关于回归的部分

```
from Andrew Plotkin: "If you already know what recursion is, just remember the answer. Otherwise, find someone who is standing closer to Douglas Hofstadter than you are; then ask him or her what recursion is."
```



Lisp 的表达式其实是一种树形结构：如(+ 9 (* (- 3 1) 3) (/ 10 2))

​					+

​		9			*				/

​				-		3		10		2

​			3		1

书中用的是另一种树形结构，称为"Percolate upward form" Of tree structure. 

​					

​							20				

​	+		9		6						5

​		*			2		3			/	10	2	

​				-     3	1			



这种evaluating过程一般称为[Tree accumulation - Wikipedia](https://en.wikipedia.org/wiki/Tree_accumulation)，即从下往上计算，页节点是符号或数字，其母节点保存页节点的计算值，依次往上类推。比如美国大选统计各州的选票便可用此方式。与之相反的另一种evaluating过程称为Downward accumulation，即从上而下 refers to accumulating on each node information of every ancestor，

这种树形结构有什么好处？阳志平老师提到：

```
人类的最佳知识结构是树形结构。
从树的上一层到下一层，是具备唯一通道，便于大脑将知识从记忆底层快速提取出来
树同时又兼具横向和纵向扩展的优雅结构
```

【**TODO**】那是不是可以理解，这种树形结构也是计算机容易理解的呢？树形结构和递归有什么关联？

【**TODO**】我们常用的表达方式（9+（3-1）*3+10/2），如果一定要写成树形的话，似乎也可以写。但第一感觉似乎还是偏于扁平结构了

变量的环境？

【TODO】递归有什么用？目前想到的是可以简化代码的实现，但增加了计算难度，好像性能也不是很好

## 复杂程式（ Compound Procedure）

重温一下本章开始作者提到的编程语言的要素：

- 数字和运算操作是基本的数据和程式(procedure)
- 上述基本数据和程式相组合而成的嵌套组合
- 抽象定义（名-值对）【】

### 定义

我们从 2 + 3, 到 x = 2, y = 3, x + y, 到 (+ x (* y 3)), 这些算是前两个要素，如果我们要把它抽象一下，用一个general的表达方式来呈现，以后我们只要给定一个（名 值）对，就能表示(+ x (* y 3))设置更复杂的，那多方便。这便有了Procedure definition，用我现在所学的来理解就是Function，定义一个函数，有一个函数名，传一个或多个参数，函数体便是(+ x (* y 3))。

Python

```
def square(x):
	return x * x
```

Lisp

```
(define (square x) (* x x)
```

Lisp的表达看起来没有Python的简洁，但是它可以“直译”成我们使用的语言，让我感觉很惊艳：

(define (		square 		x	) (	* 		x 		x	)

​       To     	 square  something, multiple 	it	 by	 itself

是不是有种如果我直接写英文语句，可以让计算机转换成Lisp？不知道有没有人试验过呢

在这个例子中，(* x x)是一个复杂程式(compound procedure)，我们给了它一个名字“square"。

通用的表达方式是：

(define	(<procedure_name> 	<formal_parameters>)

(<procedure_body>)

)

### 使用

如何来用呢？

Python

```
square(2)
square(sqaure(2))
```

Lisp

```
(square 2)
(sqaure (sqaure 2))
```



## Substition Module

我们知道了如何定义和使用复杂程式，那解析器是如何解析复杂程式的呢？

```
the interpreter evaluates the elements of the combination and applies the procedure (which is the value of the operator of the combination) to the arguments (which are the values of the operands of the combination).
```

听起来有点绕，复杂的事情总是由简单的事情组成的。我们可以先从简单的表达式说起，比如 x + y这个简单组合。+ 是这个组合操作符的值(the value of the operator of the combination), 代表了一个操作（加）， x 和 y 是这个组合的操作数的值（the values of the operands of the combination)，解析器要做的便是，找到 x, y，将+操作应用到x和y上。

同样，对于一个复杂的函数操作，

```
To apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument.
```

以(square 5)为例：

- 解析器找到square函数的body (* x x ), 变成 (* x x), 

- 将x用5替代，变成( * 5 5)

  这便简单了。

如果再复杂点 (square (square 5))呢？

- 先找到最外层sqaure的body(* x x ), 变成(	* (square 5) (square 5)	)
	 将内层的square body替换，变成(	* (* x x) (* x x)	)
	 将x用5替代，变成(	* (* 5 5) (* 5 5)	)
- 分别计算两个(* 5 5)，变成(* 25 25)
- 得出结果 625

上述的这些操作中，在函数使用的时候，涉及到将实际的参数值（argument）替换到函数的body中，这个过程便称为substition model。

目前上述的解析器操作只是一个为了方便理解二设的”粗糙“的模型，后续会慢慢改进，接近解析器原始面纱。

作者后面提到两种解析顺序：

- Applicative Model（evaluate the arguments and then apply）

  Lisp用此模式，先解析操作数，后apply 操作符

- Normal Mode（fully expand and then reduce）

  先将所有的元素都解析成最原始的操作符，再将操作数代入。这种显然复杂啊

## 条件表达式和断言(predicate)

前面讲了如何定义一个函数来做一些复杂的事情，但还只限于给定一个或者多个值，返回某个值。

现实中的一些“如果”‘现象还未能处理，比如下面这种case:

```
如果明天下雨，带雨伞
太阳晒，则带遮阳伞
```

我们来定义一个函数 umbrella_x, 参数设为天气，umbrella_x(weather), 怎么来写body呢？

或者这种case:

|x| = {  

​		x if x > 0;

​		0 if x = 0;

​		-x if x < 0

​	 }

这种结构作者称为case analysis, 要用到条件语句了

Python

```
def f(x):
	if x == 0:
		return 0
	elif x > 0:
		return x
	else:
		return -x
```

Lisp: 用到cond关键词（一种special forms)

``` cond ( (p1)  (e1))
(define (f x)(
	cond ((= x 0) 0)
		 ((> x 0) x)
		 ((< x 0) (-x))	
	))
```

通用的表达是：

```
(cond (⟨p1⟩ ⟨e1⟩)
(⟨p2⟩ ⟨e2⟩)
. . .
(⟨pn⟩ ⟨en⟩))
)
```

(⟨pn⟩ ⟨en⟩) 称为条件句(clauses)

（pn) 称为断言(predicate)，真假值。

听起来很像是法律用语啊。如果违反了某条某条，则判有罪。

lisp也有if, else关键词，但貌似不是一起用的，至少目前看到书中的例子是这样。【】

除了> , < =等，还有 and, or, not等逻辑操作。

这里作者认为 and, or并不是procedure, 只是像define一样属于special forms，而not则是procedure。原因是，and, or中的子表达式并不是每个都会执行的。如：

对于 (and (x > 5) (x < 10)), 如果 x = 4，首先不满足 x > 5的条件，所以 x < 10 便可以不执行了，直接返回false。即所谓的short-circuit evaluation。

从这里来进一步理解Procedure：procedure的每个子表达式都必须执行后才能得到procedure的结果【】

### 解析

条件语句执行的时候，是按定义的顺序，先p1,如果p1为假则 p2….依次直至有一个Pi为真，则进入Ei执行

有点不解的是作者最后的一个例子：

```
we can define a predicate to test whether one number is greater than or equal to another as

(define (>= x y) 
  (or (> x y) (= x y)))
  
or alternatively as

(define (>= x y) 
  (not (< x y)))
```

这是要表达什么？define不是设置变量值吗，(>= x y)如何做变量用？【】

## Exercises

### 练习1：

```
Exercise 1.1: Below is a sequence of expressions. What is
the result printed by the interpreter in response to each expression?
Assume that the sequence is to be evaluated in
the order in which it is presented.

```

脑算结果：

10											|			10	
(+ 5 3 4)										|			12
(- 9 1)										| 			8
(/ 6 2)										|			3
(+ (* 2 4) (- 4 6))								|			**2**（should be 6)

(define a 3)						
(define b (+ a 1))
(+ a b (* a b))									|			19
(= a b)										|			false
```(if (and (> b a) (< b (* a b))) ```

```b ```

```a)```											|			4

```(cond ((= a 4) 6) ```

```((= b 4) (+ 6 7 a)) ```						|			16

```(else 25))```
(+ 2 (if (> b a) b a))							|			6

(* (cond ((> a b) a)
((< a b) b)
(else -1))
(+ a 1))										|			16

![image-20180522213107648](https://ws3.sinaimg.cn/large/006tKfTcly1frkfwj2ik1j30ra0kw0uk.jpg)

电脑计算结果中最后多出一个4，看了一下，应该是配置f5的问题，先不管了。

lisp中的布尔值“假”显示为#f，挺特别的。

### 练习2

![image-20180522213823885](https://ws4.sinaimg.cn/large/006tKfTcly1frkg43gn08j30m304jaaq.jpg)

```
(/ (+ 5 4 (- 2 3 (+ 6 (/ 4 5))))
(* 3 (- 6 2) (- 2 7))
)

```

![image-20180522215104643](https://ws4.sinaimg.cn/large/006tKfTcly1frkgha5z1aj30cv0eg74y.jpg)

计算结果好像不那么正确啊，看着表达式似乎正确呢

python试了一下结果是 - 14.8/60

还没找出原因来。。。先不纠结了，这不是重要问题。

不过lisp结果为啥还带着除号呢，不直接计算得出浮点数呢？【】

### 练习3

```
Exercise 1.3: Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.
```

试着写了一段，但是跑不起来，总是说procedure not defined…先不纠结了，知道大概意思，以后再revisit吧

![image-20180523232204768](/var/folders/yc/f8v7n2n54wj9hbqbx6kmrs8r0000gn/T/abnerworks.Typora/image-20180523232204768.png)

### 练习4

```
Exercise 1.4: Observe that our model of evaluation allows for combinations whose operators are compound expressions. Use this observation to describe the behavior of the following procedure:

(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```



### 练习5

